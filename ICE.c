// adapted from libvmi mem_evet example

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <inttypes.h>
#include <signal.h>
#include <glib.h>

#include <libvmi/libvmi.h>
#include <libvmi/events.h>

#define PAGE_SHIFT 12
#define PAGESIZE 4096

static bool interrupted = false;

static addr_t kernel_text_start_GVA;
static addr_t kernel_text_end_GVA;

static void close_handler(int sig) {
    (void) sig;
    interrupted = true;
}

event_response_t singlestep_cb(vmi_instance_t vmi, vmi_event_t *event) {
    addr_t gfn = GPOINTER_TO_SIZE(event->data);
    if (vmi_set_mem_event(vmi, gfn, VMI_MEMACCESS_W, 0) == VMI_FAILURE) {
        fprintf(stderr, "ICE: singlestep_cb failed to set page permissions on gfn %llx\n", gfn);
    }

    return VMI_EVENT_RESPONSE_TOGGLE_SINGLESTEP;
}

// int register_singlestep_event(vmi_instance_t vmi, void *cb, vmi_event_t *singlestep_event_ptr) {
//     SETUP_SINGLESTEP_EVENT(singlestep_event_ptr, VMI_BIT_MASK(0, vmi_get_num_vcpus(vmi) - 1), cb, false);
//     if (VMI_FAILURE == vmi_register_event(vmi, singlestep_event_ptr)) {
//         return 1;
//     }
//     return 0;
// }

event_response_t mem_cb(vmi_instance_t vmi, vmi_event_t *event) {
    if (event->x86_regs->rip > kernel_text_start_GVA & event->x86_regs->rip < kernel_text_end_GVA) {
        // printf("ICE; %RIP GVA %llx in kernel text, ignoring violation...\n", event->x86_regs->rip, event->mem_event.gfn << PAGE_SHIFT);
        if (vmi_set_mem_event(vmi, event->mem_event.gfn, VMI_MEMACCESS_N, 0) == VMI_FAILURE) {
            fprintf(stderr, "ICE: mem_cb failed to set page permissions on gfn %llx\n", event->mem_event.gfn);
        }
        vmi_event_t *singlestep_event_ptr = (vmi_event_t *) event->data;
        singlestep_event_ptr->data = GSIZE_TO_POINTER(event->mem_event.gfn);

        return VMI_EVENT_RESPONSE_TOGGLE_SINGLESTEP;
    }
    else {
        // inject fault, then dump dmesg ??
        printf("ICE: !! EPT WRITE VIOLATION @ GFN %llx\n", event->mem_event.gfn);
        printf("ICE:                        @ GPA %llx\n", event->mem_event.gfn << PAGE_SHIFT);
        printf("ICE:                        @ %RIP GVA %llx\n", event->x86_regs->rip);
        printf("ICE:                          !! %RIP IS NOT IN KERNEL TEXT\n");
        printf("ICE: pausing vm...\n");
        vmi_pause_vm(vmi);
    }

    return VMI_EVENT_RESPONSE_NONE;
}

int register_mem_event_range(vmi_instance_t vmi, addr_t GVA_start, addr_t GVA_end, vmi_mem_access_t access_type, void *cb, vmi_event_t *mem_event_ptr) {
        printf("ICE: registering mem_event on GVA range (%llx -> %llx)\n", GVA_start, GVA_end);
        GVA_start = (GVA_start >> PAGE_SHIFT) << PAGE_SHIFT;
        GVA_end = (GVA_end >> PAGE_SHIFT) << PAGE_SHIFT;

        addr_t GPA_start;
        addr_t GPA_end;
        vmi_translate_kv2p(vmi, GVA_start, &GPA_start);
        vmi_translate_kv2p(vmi, GVA_end, &GPA_end);

        uint64_t gfn_start = GPA_start >> PAGE_SHIFT;
        uint64_t gfn_end = GPA_end >> PAGE_SHIFT;

        uint64_t n_frames = (GVA_end - GVA_start) / PAGESIZE;
        printf("ICE: range aligned to page boundaries (%llx -> %llx), %lli frames\n", GVA_start, GVA_end, n_frames);

        SETUP_MEM_EVENT(mem_event_ptr, ~0ULL, access_type, cb, true);
        if (VMI_FAILURE == vmi_register_event(vmi, mem_event_ptr)) {
            fprintf(stderr, "ICE: register_mem_event_range failed\n");
            return 1;
        }

        for (uint64_t i = gfn_start; i < gfn_end; i++) {
            if (VMI_FAILURE == vmi_set_mem_event(vmi, i, access_type, 0)) {
                fprintf(stderr, "ICE: register_mem_event_range failed to set page permissions on gfn %llx\n", i);
                return 1;
            }
        }

        printf("ICE: registered mem_event on GVA range (%llx -> %llx)\n", GVA_start, GVA_end);

        return 0;
}

int main(int argc, char **argv) {
    vmi_instance_t vmi = {0};
    vmi_mode_t mode = {0};
    vmi_event_t mem_event = {0};
    vmi_event_t singlestep_event = {0};
    struct sigaction act = {0};
    vmi_init_data_t *init_data = NULL;
    int status = 1;

    act.sa_handler = close_handler;
    act.sa_flags = 0;
    sigemptyset(&act.sa_mask);
    sigaction(SIGHUP,  &act, NULL);
    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGINT,  &act, NULL);
    sigaction(SIGALRM, &act, NULL);

    if (argc < 2) {
        fprintf(stderr, "usage: %s <domain name>\n", argv[0]);
        return status;
    }

    unsigned char logo[] = {
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f,
      0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x5c, 0x20,
      0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x5c, 0x20,
      0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x5c, 0x20,
      0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5c,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5c,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5c,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x2f, 0x5c, 0x2f, 0x3a, 0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20,
      0x2f, 0x5c, 0x2f, 0x3a, 0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20,
      0x2f, 0x5c, 0x2f, 0x3a, 0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x0a, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x3a, 0x2f, 0x5c, 0x2f, 0x5f, 0x5f,
      0x2f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x3a, 0x2f, 0x5c, 0x2f, 0x5f, 0x5f,
      0x2f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x3a, 0x2f, 0x5c, 0x2f, 0x5f, 0x5f,
      0x2f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c,
      0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c,
      0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c,
      0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x2f, 0x3a, 0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x2f, 0x3a, 0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x2f, 0x3a, 0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x2f, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x2f, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x2f, 0x5c, 0x3a, 0x5c,
      0x5f, 0x5f, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x20,
      0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x20,
      0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x20, 0x5c, 0x2f, 0x5f, 0x5f, 0x2f, 0x0a,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x5f, 0x0a, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x5c, 0x20, 0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x3a,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x3a,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x3a,
      0x3a, 0x5c, 0x20, 0x20, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x3a, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x3a, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x20, 0x20, 0x20, 0x2f, 0x3a, 0x3a, 0x5c,
      0x3a, 0x5c, 0x5f, 0x5f, 0x5c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x3a,
      0x5c, 0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x3a,
      0x5c, 0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c, 0x3a,
      0x5c, 0x2f, 0x20, 0x20, 0x2f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x2f, 0x20, 0x20, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x3a, 0x5c,
      0x2f, 0x20, 0x20, 0x2f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x2f, 0x5f,
      0x5f, 0x2f, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x48, 0x56, 0x43, 0x49,
      0x63, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6e, 0x74, 0x72, 0x75,
      0x73, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72,
      0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x20, 0x65, 0x6c, 0x65, 0x63,
      0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63, 0x73, 0x20, 0x76, 0x30, 0x2e, 0x34,
      0x0a, 0x0
    };

    printf("%s\n\n", logo);
    printf("ICE: connecting to domain %s... ", domain_name);

    char *domain_name = argv[1];
    if (VMI_FAILURE == vmi_get_access_mode(NULL, (void*) domain_name, VMI_INIT_DOMAINNAME | VMI_INIT_EVENTS, init_data, &mode)) {
        fprintf(stderr, "\nICE: failed to get access mode\n");
        goto error_exit;
    }
    if (VMI_FAILURE == vmi_init_complete(&vmi, (void*) domain_name, VMI_INIT_DOMAINNAME | VMI_INIT_EVENTS, init_data, VMI_CONFIG_GLOBAL_FILE_ENTRY, NULL, NULL)) {
        fprintf(stderr, "\nICE: failed to init libVMI library.\n");
        goto error_exit;
    }

    vmi_init_paging(vmi, 0);
    printf("done\n");

    printf("ICE: pausing vm... ");
    if (VMI_FAILURE ==  vmi_pause_vm(vmi)) {
        fprintf(stderr, "Failed to pause vm\n");
        goto error_exit;
    }
    printf("done\n");

    // addr_t kernel_text_start_GVA;
    // addr_t kernel_text_end_GVA;
    addr_t kernel_text_start_GPA;
    addr_t kernel_text_end_GPA;

    vmi_translate_ksym2v(vmi, "_text", &kernel_text_start_GVA);
    vmi_translate_kv2p(vmi, kernel_text_start_GVA, &kernel_text_start_GPA);
    printf("ICE: kernel text start @ GVA %llx\n", kernel_text_start_GVA);
    printf("                       @ GPA %llx\n", kernel_text_start_GPA);

    vmi_translate_ksym2v(vmi, "_etext", &kernel_text_end_GVA);
    vmi_translate_kv2p(vmi, kernel_text_end_GVA, &kernel_text_end_GPA);
    printf("ICE: kernel text end @ GVA %llx\n", kernel_text_end_GVA);
    printf("                     @ GPA %llx\n", kernel_text_end_GPA);

    // if (register_singlestep_event(vmi, singlestep_cb, &singlestep_event)
    //     != 0) {
    //     goto error_exit;
    // }
    SETUP_SINGLESTEP_EVENT(&singlestep_event, VMI_BIT_MASK(0, vmi_get_num_vcpus(vmi) - 1), singlestep_cb, false);
    if (VMI_FAILURE == vmi_register_event(vmi, &singlestep_event)) {
        goto error_exit;
    }

    mem_event.data = (void *) &singlestep_event;
    if (register_mem_event_range(vmi, kernel_text_start_GVA, kernel_text_end_GVA, VMI_MEMACCESS_W, mem_cb, &mem_event)
        != 0) {
        goto error_exit;
    }

    if (VMI_FAILURE == vmi_resume_vm(vmi)) {
        fprintf(stderr, "ICE: failed to resume vm\n");
        goto error_exit;
    }
    printf("ICE: VM resumed\n");

    printf("ICE: EPT write protection set on GVA range (%llx -> %llx), waiting for violations...\n", kernel_text_start_GVA, kernel_text_end_GVA);
    while (!interrupted) {
        vmi_events_listen(vmi,500);
    }

    status = 0;
error_exit:
    // free all mem events and free array
    // unregister_mem_event_range(vmi, mem_event_arr, nframes);
    vmi_clear_event(vmi, &mem_event, NULL);
    vmi_resume_vm(vmi);
    vmi_destroy(vmi);

    return status;
}
